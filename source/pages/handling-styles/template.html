[! extends "wrappers/main-wrapper.html" !]

[! block body !]

<h2>Introduction</h2>

<p>
  One aspect of web components I struggle with is
  that they never feel self-contained. The main
  place I feel that friction is with styles. Specifically:
</p>

<ul>
  <li>
    <p>
      I'm having to apply a <code>display: block;</code> 
      in the parent page's CSS to get my components to render 
      properly. Or, I have to add <code>display: inline-block</code>
      if I want the behavior
    </p>
  </li>
  <li>
    Components have access to the CSS variables set
    on the parent page. That's great as far as it goes, but
    the way I'd been thinking about it, it required 
    adjusting the CSS for the parent page itself
    to set specific variable names the component
    expects
  </li>
</ul>

<p>
  In both cases, using the component requires messing
  with the parent page's CSS. I really don't like the
  way that feels. I had a couple realizations 
  about how to address those issues. This page is for
  taking a look at them. 
</p>
<p>
  Fair warning: I'm still new to web components. 
  I may be off-base here. Part of the reason I'm doing
  this write up it to solicit feedback. 
</p>
<p>
  With that said, here's what I'm doing:
</p>

<h2>Overview</h2>

<p>
  There are two techniques I'm using to address working
  with styles:
</p>

<ol>
  <li>
    Add styles to the parent page by creating a new element and 
    appending it to the page via <code>document.head</code>
    from the component's <code>.js</code> file before 
    defining the component itself
  </li>
  <li>
    Pass the names of CSS variables (or specific values) 
    I want to use into the component via attributes 
    in the custom element's tag
  </li>
</ol>

<p>
  I can use a component on a page without having
  to adjust the parent's CSS at all when I use
  these methods. The only thing I have to touch is 
  the component's custom element tag and its attributes. 
</p>

<h2>The Component File</h2>

<p>
  Here's a full example 
  where I'm using the techniques. This is 
  also the code that powers the examples on this page:
</p>

  <pre><code>[@ page.highlighted_component() @]</code></pre>

<p>
  We'll dig into the details in a moment. 
  Before we do, here's a look at how it's used:
</p>

<h2>Basic Usage</h2>

<p>
  The component's filename is <code>component.js</code>. 
  It's included via this tag that's
  placed just before the page's closing <code>body</code>
  tag:
</p>
  
<div>
<pre><code>[@ page.highlighted_snippet("script.html") @]</code></pre>
</div>

<h3>Example 1</h3>
<p>
  The component provides a custom element named <code>aws-wc</code>
  (where &quot;aws&quot; stands for <em>alan w smith</em>. Not
  the web services company) that outputs the word &quot;Ping&quot;
  with a background color behind it. The basic use looks like this:
</p>

<div class="example-block flow">
  <h4>Code</h4>
  <pre><code>[@ page.highlighted_snippet("1.html") @]</code></pre>
  <h4>Result</h4>
  <div>
    [@ page.snippet("1.html") @]
  </div>
</div>

<p>
  The component defaults the background color 
  to <code>blue</code>. The text color is 
  inherited.
</p>

<h3>Example 2</h3>
<p>
  The component is designed to do very little. The 
  idea being to keep the examples as clear as possible. 
  One feature it does have is the ability to pass
  a color to use for the background via a 
  &quot;backgroundColor&quot; attribute like this:
</p>

<div class="example-block flow">
  <h4>Code</h4>
  <pre><code>[@ page.highlighted_snippet("2.html") @]</code></pre>
  <h4>Result</h4>
  <div>
    [@ page.snippet("2.html") @]
  </div>
</div>

<h2>Using CSS Variables</h2>
<p>
  Even better than being able to pass explicit 
  colors is the ability to pass CSS 
  variables defined by the parent page's styles. 
</p>

<h3>Example 3</h3>

<p>
  This page includes the following in its stylesheets:
</p>

<div>
  <pre><code>[@ page.highlighted_styles() @]</code></pre>
</div>

<p>
  <code>--accent-color-1</code> is what's used for the
  borders of the code/result example blocks
  on this page. We can set a component to use the 
  same variable for its background like this:
</p>

<div class="example-block flow">
  <h4>Code</h4>
  <pre><code>[@ page.highlighted_snippet("3.html") @]</code></pre>
  <h4>Result</h4>
  <div>
    [@ page.snippet("3.html") @]
  </div>
</div>

<p>
  The name of the variable is passed into a function that
  builds the stylesheet for the component's 
  shadowroot. Once there, it grabs the associated
  value from the parent page's styles like
  a regular CSS variable call.
</p>

<h3>Example 4</h3>
<p>
  Component instances are isolated from each 
  other. We can use different variables for 
  each one: 
</p>

<div class="example-block flow">
  <h4>Code</h4>
  <pre><code>[@ page.highlighted_snippet("4.html") @]</code></pre>
  <h4>Result</h4>
  <div>
    [@ page.snippet("4.html") @]
  </div>
</div>

<h3>Example 5</h3>

<p>
  The same technique can be used with multiple
  styles. Here's  an instance that
  uses a <code>textColor</code> in addition to the
  <code>backgroundColor</code>:
</p>

<div class="example-block flow">
  <h4>Code</h4>
  <pre><code>[@ page.highlighted_snippet("5.html") @]</code></pre>
  <h4>Result</h4>
  <div>
    [@ page.snippet("5.html") @]
  </div>
</div>

<h2>Adding Styles To The Parent Page</h2>
<p>
  It's time to start looking at the component file itself. 
</p>
<p>
  Our <code>aws-wc</code> component is designed to work as 
  a <em>display: inline-block</em> element.
  We have to set the style to avoid it taking up an
  entire row. 
</p>
<p>
  I originally thought this
  meant having to modify the parent page's CSS directly. 
  That's not the case. We can do it in the same <code>.js</code>
  file that contains our component by adding a 
  stylesheet outside the definition of the component's class. 
</p>
<p>
  Here's the top of the <em>component.js</em> file where
  we do just that: 
</p>

<pre><code>[@ page.highlighted_component(1, 7) @]</code></pre>

<p>
  This fires when the script is loaded on the page. 
  It only fires once instead of each time an instance 
  is created because it's outside the component's 
  class definition. 
</p>

<h2>Passing Style Variables To The Component</h2>

<h3>Using The ShadowDOM</h3>

<p>
  The component is set up to use the shadowDOM with the
  <code>this.attachShadow({mode: 'open'})</code> call
  in the constructor:
</p>

<pre><code>[@ page.highlighted_component(10, 13) @]</code></pre>

<h3>Getting The Attribute Values</h3>

<p>
  Pulling style variables (or, explicit values) in from
  a custom tag's attributes takes a few steps. The first
  thing is to add a function to the component's 
  <code>connectedCallback()</code> to grab the values
  from the attributes. Here's the code where I'm calling
  a <code>this.getColors()</code> function:
</p>

<pre><code>[@ page.highlighted_component(15, 21) @]</code></pre>

<p>
  The function looks like this:
</p>

<pre><code>[@ page.highlighted_component(23, 32) @]</code></pre>

<p>
  The code checks to see if the color attributes
  exist in the custom element. They get used if they do.
  Otherwise, a default fallback gets set.
</p>

<h3>Applying The Styles</h3>

<p>
  The internal stylesheet for the component is
  generated by the <code>styles()</code> function:
</p>

<pre><code>[@ page.highlighted_component(41, 51) @]</code></pre>

<p>
  It uses the <code>this.backgroundColor</code> and
  <code>this.textColor</code> variables defined by
  the <code>getColors()</code> function. They are
  written in as strings which is what allows them
  to accept CSS variable names.
</p>
<p>
  There's no difference
  to the component compared to hard coding the 
  variable names.
<p>

<p>
  The styles are added to the shadowroot from the 
  <code>connectedCallback()</code> function with:
</p>

<pre><code>[@ page.highlighted_component(17, 17) @]</code></pre>

<h3>Adding The Content</h3>

<p>
  The body of the component is defined in the
  <code>template()</code> function:
</p>

<pre><code>[@ page.highlighted_component(34, 39) @]</code></pre>

<p>
  The <code>connectedCallback()</code> function adds the
  template to the <code>shadowRoot</code> with:
</p>

<pre><code>[@ page.highlighted_component(18, 20) @]</code></pre>

<h3>Finishing The Component</h3>

<p>
  The last step is to add the component's 
  definition to the page with:
</p>

<pre><code>[@ page.highlighted_component(55, 55) @]</code></pre>

<h2>Conclusion</h2>

<p>
  Using these techniques provides a way to make
  components that don't require messing with a 
  parent page's stylesheet. It's a much nicer
  separation of concerns. It's made me
  genuinely more excited about making 
  components. 
</p>

<hr class="hr-end" />

<h2>Endnotes</h2>
<ul>
  <li>
    This was my first run at this idea. I've received feedback
    from folks who know more about this stuff than me that
    this works fine but there are some potential improvements.
    See the TODO section below for those notes. (I'll
    update the actual examples when I'm able)
  </li>
  <li>
    I've tested this
    on Chrome, Firefox, and Safari on my mac, and
    Chrome, Edge, and Firefox on my windows machine. 
    Everything is working the same across the board. 
  </li>
  <li>
    <p>
      As mentioned in the Introduction, I'm still new to 
      working with web components. It's possible all 
      this stuff is well known in general or that there
      are other, better ways to do the same things.
    </p>
    <p>
      Part of the reason for this post it to solicit feedback 
      from folks with more experience. If you see 
      something amiss please 
      <a href="https://socials.alanwsmith.com/">let me know</a>.
    </p>
  </li>
</ul>

<h2>References</h2>


<pre>
https://developer.mozilla.org/en-US/docs/Web/CSS/:host

  https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/adoptedStyleSheets

  https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet

</pre>



<h2>TODO</h2>
<ul>
  <li>
    Put links in for the discords where folks helped out
  </li>
  <li>
    Switch to a <code>getAttributes()</code> function 
    to pull in the attributes in a single loop instead
    of having to do them explicitly by name. Then,
    you can set defaults on just the colors in 
    their own function. This puts things more in 
    line with my general approach to components. 
  </li>
  <li>
    <p>
      Look into <code>CSSStyleSheet</code> as another 
      approach for making the stylesheet. For example:
    </p>
    <pre><code>customElements.define('aws-wc', class extends HTMLElement {
constructor() {
super();
this.attachShadow({ mode: 'open' });
const styles = new CSSStyleSheet();
styles.replaceSync(`:host { display: block }`);
this.shadowRoot.adoptedStyleSheets.push(styles);
}
});</code></pre>
  </li>
  <li>
    Another possible approach for adding the stylesheet
    to the parent document is to do it in the connectedCallback. 
    The idea being to use an id that's added to the style
    tag. Before the component attempts to create it, it
    would check to see if it already exists. 
  </li>
  <li>
    Another suggestion for the id on the style tag is that
    it could be used as a more general place for components to add 
    styles without having to make new <code>&lt;style&gt;</code>
    tags all the time
  </li>
  <li>
    Check out <a href="https://knowler.dev/blog/a-mental-model-for-styling-the-shadow-dom">
      A mental model for styling the Shadow DOM
    </a> for some more thinking about the way styles interact
  </li>
  <li>
    Review <a href="https://bsky.app/profile/engelman.nl/post/3lfxapeitw22q">this method</a>
    for a possible option
  </li>
  <li>
    Note that the attributes are not responsive. See
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#responding_to_attribute_changes">
      Responding to attribute changes in Using custom elements
    </a>
    if that's a concern
  </li>
</ul>


[@ page.snippet("script.html") @]

[! endblock !]
